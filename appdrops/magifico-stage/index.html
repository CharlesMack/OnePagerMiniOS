<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Magifico's Realistic Magic Experience</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: radial-gradient(circle at center, #0a0015, #1a0033, #000000);
      overflow: hidden;
      color: white;
      font-family: 'Georgia', serif;
      cursor: none;
    }
    #canvas-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    #custom-cursor {
      position: fixed;
      width: 30px;
      height: 30px;
      border: 2px solid rgba(255, 215, 0, 0.8);
      border-radius: 50%;
      pointer-events: none;
      z-index: 1000;
      transition: transform 0.1s ease;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.5), inset 0 0 10px rgba(255, 255, 255, 0.2);
    }
    #ui {
      position: absolute;
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      justify-content: center;
    }
    #performance-stats {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 10px;
      border: 1px solid gold;
      font-size: 12px;
      z-index: 15;
    }
    #magic-meter {
      position: absolute;
      top: 20px;
      left: 20px;
      width: 200px;
      height: 30px;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid gold;
      border-radius: 15px;
      overflow: hidden;
      z-index: 15;
    }
    #magic-fill {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, #4B0082, #8A2BE2, #FFD700);
      transform: scaleX(0);
      transform-origin: left;
      transition: transform 0.5s ease;
      position: relative;
    }
    #magic-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      animation: shimmer 2s infinite;
    }
    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }
    #timeline {
      position: absolute;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      height: 40px;
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid gold;
      border-radius: 20px;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 15px;
      font-size: 14px;
      box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
    }
    #progress-bar {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, rgba(138, 43, 226, 0.8), rgba(255, 215, 0, 0.8));
      transition: width 0.1s linear;
    }
    #caption {
      position: absolute;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(75, 0, 130, 0.3));
      backdrop-filter: blur(10px);
      padding: 20px 30px;
      border-radius: 25px;
      border: 2px solid gold;
      font-size: 18px;
      opacity: 0;
      transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      z-index: 20;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
      box-shadow: 0 0 40px rgba(255, 215, 0, 0.2);
    }
    button, select {
      background: linear-gradient(135deg, #4B0082, #6600cc);
      border: 2px solid gold;
      color: white;
      padding: 15px 25px;
      border-radius: 25px;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3), inset 0 1px 3px rgba(255, 255, 255, 0.2);
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      position: relative;
      overflow: hidden;
    }
    button:hover, select:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(255, 215, 0, 0.4);
      border-color: #FFD700;
    }
    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }
    button:hover::before {
      left: 100%;
    }
    select {
      padding: 15px 20px;
      background: linear-gradient(135deg, #2a0045, #4B0082);
    }
    #floating-particles {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
    }
    .particle {
      position: absolute;
      width: 3px;
      height: 3px;
      background: radial-gradient(circle, #FFD700, transparent);
      border-radius: 50%;
      opacity: 0.8;
      animation: float 4s infinite ease-in-out;
    }
    @keyframes float {
      0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0; }
      50% { opacity: 1; }
      25% { transform: translateY(-20px) rotate(90deg); }
      75% { transform: translateY(-10px) rotate(180deg); }
    }
    #instructions {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 10px;
      border: 1px solid gold;
      font-size: 12px;
      max-width: 300px;
    }
    @media (max-width: 768px) {
      #ui { bottom: 80px; flex-direction: column; align-items: center; }
      #timeline { bottom: 20px; height: 35px; }
      #instructions { display: none; }
    }
  </style>
</head>
<body>
  <div id="canvas-container">
    <canvas id="magic-canvas"></canvas>
    <div id="custom-cursor"></div>
    <div id="floating-particles"></div>
    
    <div id="performance-stats">
      <div>üîÆ Magic Level: <span id="magic-level">100%</span></div>
      <div>‚ú® Effects: <span id="active-effects">0</span></div>
      <div>üé≠ Act: <span id="current-act">Standby</span></div>
    </div>

    <div id="magic-meter">
      <div id="magic-fill"></div>
    </div>

    <div id="caption"></div>

    <div id="ui">
      <select id="actSelector">
        <option value="act1">üé≠ Act I: Mystical Awakening</option>
        <option value="act2">‚ú® Act II: Elemental Mastery</option>
        <option value="act3">üåü Act III: Reality Bending</option>
        <option value="act4">üîÆ Act IV: Cosmic Finale</option>
      </select>
      <button onclick="startShow()">üé¨ Begin Performance</button>
      <button onclick="runSelectedScript()">üéüÔ∏è Cast Selected Spell</button>
      <button onclick="createPortal()">üåÄ Open Portal</button>
      <button onclick="summonElements()">üî• Summon Elements</button>
    </div>

    <div id="timeline">
      <div id="progress-bar"></div>
      <span>Magical Timeline</span>
    </div>

    <div id="instructions">
      <strong>üéÆ Interactive Controls:</strong><br>
      ‚Ä¢ Move mouse to control magical energy<br>
      ‚Ä¢ Click anywhere to cast sparkles<br>
      ‚Ä¢ T - Telekinesis ‚Ä¢ R - Rabbit trick<br>
      ‚Ä¢ L - Levitation ‚Ä¢ C - Color magic<br>
      ‚Ä¢ D - Disappearing act ‚Ä¢ S - Start show<br>
      ‚Ä¢ Space - Random magic burst
    </div>
  </div>

  <script>
    let scene, camera, renderer, light, ambient;
    let wand, cape, card, stage, rabbit;
    let particleSystem, sparkleSystem, portalSystem;
    let idleTimer, mousePos = { x: 0, y: 0 };
    let currentScript = [];
    let scriptStartTime, scriptDuration = 0;
    let progressInterval;
    let magicLevel = 100;
    let activeEffects = 0;
    let isPerforming = false;

    // Enhanced particle systems
    const particles = [];
    const sparkles = [];
    const magicTrails = [];
    
    const trickList = [doTrick, rabbitPop, levitateObject, disappearCard, colorCape, createPortal, summonElements];

    function init() {
      scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x000011, 10, 50);
      
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, 12);
      
      renderer = new THREE.WebGLRenderer({ 
        canvas: document.getElementById('magic-canvas'), 
        antialias: true,
        alpha: true
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.setClearColor(0x000000, 0);

      // Enhanced lighting system
      light = new THREE.SpotLight(0xffd700, 2, 30, Math.PI/6, 0.5, 2);
      light.position.set(0, 15, 8);
      light.target.position.set(0, 0, 0);
      light.castShadow = true;
      light.shadow.mapSize.width = 2048;
      light.shadow.mapSize.height = 2048;
      scene.add(light);
      scene.add(light.target);

      // Multiple colored lights for ambiance
      const ambientColors = [0x4B0082, 0x8A2BE2, 0x9400D3];
      ambientColors.forEach((color, i) => {
        const ambLight = new THREE.PointLight(color, 0.3, 20);
        ambLight.position.set(
          Math.cos((i * Math.PI * 2) / 3) * 8,
          3,
          Math.sin((i * Math.PI * 2) / 3) * 8
        );
        scene.add(ambLight);
      });

      ambient = new THREE.AmbientLight(0x330066, 0.2);
      scene.add(ambient);

      createStage();
      createMagicItems();
      createParticleSystems();
      setupEventListeners();
      createFloatingParticles();

      animate();
      startIdleCycle();
    }

    function createStage() {
      // Enhanced stage with realistic materials
      const stageGeo = new THREE.CylinderGeometry(8, 8, 0.5, 32);
      const stageMat = new THREE.MeshLambertMaterial({ 
        color: 0x2a0845,
        transparent: true,
        opacity: 0.8
      });
      stage = new THREE.Mesh(stageGeo, stageMat);
      stage.position.y = -3;
      stage.receiveShadow = true;
      scene.add(stage);

      // Stage edge glow
      const edgeGeo = new THREE.TorusGeometry(8, 0.1, 8, 32);
      const edgeMat = new THREE.MeshBasicMaterial({ 
        color: 0xffd700,
        transparent: true,
        opacity: 0.6
      });
      const stageEdge = new THREE.Mesh(edgeGeo, edgeMat);
      stageEdge.position.y = -2.7;
      stageEdge.rotation.x = Math.PI / 2;
      scene.add(stageEdge);
    }

    function createMagicItems() {
      // Enhanced wand with realistic details
      const wandGroup = new THREE.Group();
      
      const handleGeo = new THREE.CylinderGeometry(0.08, 0.06, 1.5, 12);
      const handleMat = new THREE.MeshPhongMaterial({ 
        color: 0x8B4513,
        shininess: 30,
        specular: 0x222222
      });
      const wandHandle = new THREE.Mesh(handleGeo, handleMat);
      wandHandle.castShadow = true;
      
      const tipGeo = new THREE.SphereGeometry(0.1, 12, 8);
      const tipMat = new THREE.MeshPhongMaterial({ 
        color: 0xffd700,
        emissive: 0x443300,
        shininess: 100
      });
      const wandTip = new THREE.Mesh(tipGeo, tipMat);
      wandTip.position.y = 0.75;
      wandTip.castShadow = true;

      wandGroup.add(wandHandle);
      wandGroup.add(wandTip);
      wandGroup.position.set(-3, 0, 0);
      wandGroup.rotation.z = Math.PI / 6;
      wand = wandGroup;
      scene.add(wand);

      // Enhanced cape with flowing effect
      const capeGeo = new THREE.PlaneGeometry(2, 3, 10, 15);
      const capeMat = new THREE.MeshLambertMaterial({ 
        color: 0x4B0082,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.9
      });
      cape = new THREE.Mesh(capeGeo, capeMat);
      cape.position.set(0, 0, -1);
      cape.castShadow = true;
      scene.add(cape);

      // Animated playing card
      const cardGeo = new THREE.PlaneGeometry(1.2, 1.8);
      const cardMat = new THREE.MeshLambertMaterial({ 
        color: 0xffffff,
        transparent: true,
        opacity: 1
      });
      card = new THREE.Mesh(cardGeo, cardMat);
      card.position.set(3, 0, 0);
      card.castShadow = true;
      scene.add(card);

      // Magic rabbit (initially hidden)
      const rabbitGeo = new THREE.SphereGeometry(0.5, 12, 8);
      const rabbitMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
      rabbit = new THREE.Mesh(rabbitGeo, rabbitMat);
      rabbit.position.set(0, -5, 0);
      rabbit.castShadow = true;
      scene.add(rabbit);
    }

    function createParticleSystems() {
      // Enhanced particle system with multiple types
      const particleCount = 200;
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      const sizes = new Float32Array(particleCount);

      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 20;
        positions[i * 3 + 1] = Math.random() * 10;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 20;

        const color = new THREE.Color();
        color.setHSL(Math.random() * 0.3 + 0.7, 1, 0.5);
        colors[i * 3] = color.r;
        colors[i * 3 + 1] = color.g;
        colors[i * 3 + 2] = color.b;

        sizes[i] = Math.random() * 3 + 1;
      }

      const particleGeo = new THREE.BufferGeometry();
      particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      particleGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      particleGeo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

      const particleMat = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 }
        },
        vertexShader: `
          attribute float size;
          attribute vec3 color;
          varying vec3 vColor;
          uniform float time;
          
          void main() {
            vColor = color;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = size * (300.0 / -mvPosition.z) * (sin(time * 2.0 + position.x) * 0.5 + 1.0);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          varying vec3 vColor;
          
          void main() {
            float distance = length(gl_PointCoord - vec2(0.5));
            if (distance > 0.5) discard;
            
            float alpha = 1.0 - (distance * 2.0);
            gl_FragColor = vec4(vColor, alpha * 0.8);
          }
        `,
        transparent: true,
        vertexColors: true,
        blending: THREE.AdditiveBlending
      });

      particleSystem = new THREE.Points(particleGeo, particleMat);
      scene.add(particleSystem);
    }

    function setupEventListeners() {
      document.addEventListener('keydown', handleKeyControls);
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('click', handleClick);
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
          e.preventDefault();
          createMagicBurst();
        }
      });
      
      window.addEventListener('resize', handleResize);
    }

    function handleMouseMove(event) {
      mousePos.x = (event.clientX / window.innerWidth) * 2 - 1;
      mousePos.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      // Update custom cursor
      const cursor = document.getElementById('custom-cursor');
      cursor.style.left = event.clientX - 15 + 'px';
      cursor.style.top = event.clientY - 15 + 'px';
      
      // Create magic trail
      if (Math.random() < 0.1) {
        createSparkle(event.clientX, event.clientY);
      }
    }

    function handleClick(event) {
      createMagicBurst();
      const ripple = createRippleEffect(event.clientX, event.clientY);
      document.body.appendChild(ripple);
    }

    function createSparkle(x, y) {
      const sparkle = document.createElement('div');
      sparkle.className = 'particle';
      sparkle.style.left = x + 'px';
      sparkle.style.top = y + 'px';
      sparkle.style.animationDelay = Math.random() * 2 + 's';
      document.getElementById('floating-particles').appendChild(sparkle);
      
      setTimeout(() => sparkle.remove(), 4000);
    }

    function createRippleEffect(x, y) {
      const ripple = document.createElement('div');
      ripple.style.position = 'fixed';
      ripple.style.left = x - 25 + 'px';
      ripple.style.top = y - 25 + 'px';
      ripple.style.width = '50px';
      ripple.style.height = '50px';
      ripple.style.border = '2px solid rgba(255, 215, 0, 0.8)';
      ripple.style.borderRadius = '50%';
      ripple.style.pointerEvents = 'none';
      ripple.style.animation = 'ripple 0.8s ease-out forwards';
      ripple.style.zIndex = '999';
      
      return ripple;
    }

    function createFloatingParticles() {
      const container = document.getElementById('floating-particles');
      for (let i = 0; i < 20; i++) {
        setTimeout(() => {
          const particle = document.createElement('div');
          particle.className = 'particle';
          particle.style.left = Math.random() * window.innerWidth + 'px';
          particle.style.top = window.innerHeight + 'px';
          particle.style.animationDelay = Math.random() * 4 + 's';
          container.appendChild(particle);
          
          setTimeout(() => particle.remove(), 4000);
        }, i * 200);
      }
      
      setTimeout(createFloatingParticles, 3000);
    }

    function handleKeyControls(e) {
      const actions = {
        't': doTrick, 'r': rabbitPop, 'l': levitateObject,
        'c': colorCape, 'd': disappearCard, 's': startShow,
        '1': runSelectedScript
      };
      
      const action = actions[e.key.toLowerCase()];
      if (action) action();
    }

    function handleResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function updateMagicMeter(value) {
      magicLevel = Math.max(0, Math.min(100, value));
      const fill = document.getElementById('magic-fill');
      fill.style.transform = `scaleX(${magicLevel / 100})`;
      document.getElementById('magic-level').textContent = Math.round(magicLevel) + '%';
    }

    function updateStats() {
      document.getElementById('active-effects').textContent = activeEffects;
      document.getElementById('current-act').textContent = 
        isPerforming ? document.getElementById('actSelector').selectedOptions[0].text.split(':')[0] : 'Standby';
    }

    function doTrick() {
      if (magicLevel < 10) return;
      
      activeEffects++;
      updateMagicMeter(magicLevel - 10);
      showCaption("‚ú® Behold! The wand channels pure magical energy!");
      
      // Enhanced wand animation with particle burst
      wand.rotation.z = Math.PI / 3;
      createMagicBurst();
      
      setTimeout(() => {
        wand.rotation.z = Math.PI / 6;
        activeEffects--;
        updateStats();
      }, 2000);
    }

    function rabbitPop() {
      if (magicLevel < 15) return;
      
      activeEffects++;
      updateMagicMeter(magicLevel - 15);
      showCaption("üê∞ Abracadabra! A mystical creature appears!");
      
      // Dramatic rabbit appearance
      rabbit.position.y = -5;
      rabbit.material.opacity = 0;
      
      const popAnimation = () => {
        rabbit.position.y += 0.2;
        rabbit.material.opacity += 0.05;
        rabbit.rotation.y += 0.1;
        
        if (rabbit.position.y < 1) {
          requestAnimationFrame(popAnimation);
        } else {
          setTimeout(() => {
            const hideAnimation = () => {
              rabbit.position.y -= 0.3;
              rabbit.material.opacity -= 0.1;
              if (rabbit.position.y > -5) {
                requestAnimationFrame(hideAnimation);
              } else {
                activeEffects--;
                updateStats();
              }
            };
            hideAnimation();
          }, 3000);
        }
      };
      popAnimation();
    }

    function levitateObject() {
      if (magicLevel < 20) return;
      
      activeEffects++;
      updateMagicMeter(magicLevel - 20);
      showCaption("üåü Witness the power of telekinesis!");
      
      const originalY = card.position.y;
      let direction = 1;
      let floatCycles = 0;
      
      const levitate = () => {
        card.position.y += direction * 0.05;
        card.rotation.z += 0.02;
        
        if (card.position.y > originalY + 2) direction = -1;
        if (card.position.y < originalY - 1) {
          direction = 1;
          floatCycles++;
        }
        
        if (floatCycles < 3) {
          requestAnimationFrame(levitate);
        } else {
          card.position.y = originalY;
          card.rotation.z = 0;
          activeEffects--;
          updateStats();
        }
      };
      levitate();
    }

    function disappearCard() {
      if (magicLevel < 25) return;
      
      activeEffects++;
      updateMagicMeter(magicLevel - 25);
      showCaption("üé≠ The impossible becomes possible!");
      
      const disappear = () => {
        card.material.opacity -= 0.05;
        card.rotation.y += 0.1;
        card.scale.multiplyScalar(0.98);
        
        if (card.material.opacity > 0) {
          requestAnimationFrame(disappear);
        } else {
          setTimeout(() => {
            const reappear = () => {
              card.material.opacity += 0.05;
              card.scale.multiplyScalar(1.02);
              if (card.material.opacity < 1) {
                requestAnimationFrame(reappear);
              } else {
                card.material.opacity = 1;
                card.scale.set(1, 1, 1);
                card.rotation.y = 0;
                activeEffects--;
                updateStats();
              }
            };
            reappear();
          }, 1000);
        }
      };
      disappear();
    }

    function colorCape() {
      if (magicLevel < 15) return;
      
      activeEffects++;
      updateMagicMeter(magicLevel - 15);
      showCaption("üåà Colors of the magical spectrum dance before you!");
      
      const colors = [0x4B0082, 0x8A2BE2, 0xFF1493, 0x00FF7F, 0xFFD700, 0xFF4500];
      let colorIndex = 0;
      
      const changeColor = () => {
        cape.material.color.setHex(colors[colorIndex]);
        colorIndex = (colorIndex + 1) % colors.length;
        
        if (colorIndex !== 0) {
          setTimeout(changeColor, 300);
        } else {
          setTimeout(() => {
            cape.material.color.setHex(0x4B0082);
            activeEffects--;
            updateStats();
          }, 1000);
        }
      };
      changeColor();
    }

    function createPortal() {
      if (magicLevel < 30) return;
      
      activeEffects++;
      updateMagicMeter(magicLevel - 30);
      showCaption("üåÄ A gateway to another dimension opens!");
      
      const portalGeo = new THREE.RingGeometry(0.5, 2, 32);
      const portalMat = new THREE.MeshBasicMaterial({
        color: 0x8A2BE2,
        transparent: true,
        opacity: 0.7,
        side: THREE.DoubleSide
      });
      const portal = new THREE.Mesh(portalGeo, portalMat);
      portal.position.set(0, 2, 0);
      scene.add(portal);
      
      const animate = () => {
        portal.rotation.z += 0.1;
        portal.material.opacity = 0.7 + Math.sin(Date.now() * 0.01) * 0.3;
        portal.scale.multiplyScalar(1.02);
        
        if (portal.scale.x < 3) {
          requestAnimationFrame(animate);
        } else {
          const shrink = () => {
            portal.scale.multiplyScalar(0.95);
            portal.material.opacity -= 0.02;
            if (portal.scale.x > 0.1) {
              requestAnimationFrame(shrink);
            } else {
              scene.remove(portal);
              activeEffects--;
              updateStats();
            }
          };
          shrink();
        }
      };
      animate();
    }

    function summonElements() {
      if (magicLevel < 35) return;
      
      activeEffects++;
      updateMagicMeter(magicLevel - 35);
      showCaption("üî•üíß‚ö°üåç The four elements answer your call!");
      
      const elements = [
        { color: 0xFF4500, pos: [-2, 1, 2], name: 'Fire' },
        { color: 0x00BFFF, pos: [2, 1, 2], name: 'Water' },
        { color: 0xFFD700, pos: [-2, 1, -2], name: 'Air' },
        { color: 0x8B4513, pos: [2, 1, -2], name: 'Earth' }
      ];
      
      const elementMeshes = [];
      
      elements.forEach((element, index) => {
        const geo = new THREE.SphereGeometry(0.3, 12, 8);
        const mat = new THREE.MeshBasicMaterial({ 
          color: element.color,
          transparent: true,
          opacity: 0
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(...element.pos);
        scene.add(mesh);
        elementMeshes.push(mesh);
        
        setTimeout(() => {
          const appear = () => {
            mesh.material.opacity += 0.05;
            mesh.rotation.y += 0.1;
            mesh.position.y += Math.sin(Date.now() * 0.01 + index) * 0.01;
            
            if (mesh.material.opacity < 0.8) {
              requestAnimationFrame(appear);
            }
          };
          appear();
        }, index * 500);
      });
      
      setTimeout(() => {
        elementMeshes.forEach(mesh => {
          const disappear = () => {
            mesh.material.opacity -= 0.05;
            mesh.scale.multiplyScalar(1.05);
            if (mesh.material.opacity > 0) {
              requestAnimationFrame(disappear);
            } else {
              scene.remove(mesh);
            }
          };
          disappear();
        });
        activeEffects--;
        updateStats();
      }, 5000);
    }

    function createMagicBurst() {
      const burstCount = 50;
      for (let i = 0; i < burstCount; i++) {
        const particle = new THREE.Mesh(
          new THREE.SphereGeometry(0.05, 6, 4),
          new THREE.MeshBasicMaterial({ 
            color: Math.random() * 0xffffff,
            transparent: true,
            opacity: 1
          })
        );
        
        particle.position.set(
          (Math.random() - 0.5) * 2,
          Math.random() * 2,
          (Math.random() - 0.5) * 2
        );
        
        const velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 0.2,
          Math.random() * 0.15,
          (Math.random() - 0.5) * 0.2
        );
        
        scene.add(particle);
        particles.push({ mesh: particle, velocity, life: 1 });
      }
      
      updateMagicMeter(magicLevel - 5);
    }

    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        particle.mesh.position.add(particle.velocity);
        particle.velocity.multiplyScalar(0.98);
        particle.life -= 0.02;
        particle.mesh.material.opacity = particle.life;
        
        if (particle.life <= 0) {
          scene.remove(particle.mesh);
          particles.splice(i, 1);
        }
      }
    }

    function showCaption(text) {
      const caption = document.getElementById('caption');
      caption.textContent = text;
      caption.style.opacity = '1';
      caption.style.transform = 'translateX(-50%) scale(1.05)';
      
      setTimeout(() => {
        caption.style.opacity = '0';
        caption.style.transform = 'translateX(-50%) scale(1)';
      }, 3000);
    }

    function startShow() {
      isPerforming = true;
      updateStats();
      showCaption("üé≠ Welcome to Magifico's Mystical Performance! Prepare to be amazed!");
      
      const showSequence = [
        { delay: 2000, action: () => doTrick() },
        { delay: 4000, action: () => colorCape() },
        { delay: 6000, action: () => rabbitPop() },
        { delay: 8000, action: () => levitateObject() },
        { delay: 10000, action: () => createPortal() },
        { delay: 12000, action: () => summonElements() },
        { delay: 15000, action: () => disappearCard() },
        { delay: 17000, action: () => {
          showCaption("üåü Thank you for witnessing the impossible!");
          isPerforming = false;
          updateStats();
        }}
      ];
      
      showSequence.forEach(step => {
        setTimeout(step.action, step.delay);
      });
    }

    function runSelectedScript() {
      const act = document.getElementById('actSelector').value;
      const scripts = {
        act1: [doTrick, rabbitPop, colorCape],
        act2: [levitateObject, createPortal, disappearCard],
        act3: [summonElements, createMagicBurst, doTrick],
        act4: [createPortal, summonElements, levitateObject, disappearCard]
      };
      
      const selectedScript = scripts[act] || scripts.act1;
      
      isPerforming = true;
      updateStats();
      
      selectedScript.forEach((action, index) => {
        setTimeout(() => {
          action();
          if (index === selectedScript.length - 1) {
            setTimeout(() => {
              isPerforming = false;
              updateStats();
            }, 2000);
          }
        }, index * 2000);
      });
    }

    function startIdleCycle() {
      const idleActions = [
        () => {
          wand.rotation.z += 0.01;
          cape.rotation.z = Math.sin(Date.now() * 0.002) * 0.1;
        }
      ];
      
      setInterval(() => {
        if (!isPerforming && Math.random() < 0.3) {
          idleActions[0]();
        }
        
        // Gradually restore magic
        if (magicLevel < 100 && !isPerforming) {
          updateMagicMeter(magicLevel + 0.5);
        }
      }, 100);
    }

    function animate() {
      requestAnimationFrame(animate);
      
      // Update particle system
      if (particleSystem) {
        particleSystem.material.uniforms.time.value = Date.now() * 0.001;
        particleSystem.rotation.y += 0.001;
      }
      
      // Update camera based on mouse
      camera.position.x += (mousePos.x * 2 - camera.position.x) * 0.02;
      camera.position.y += (-mousePos.y * 2 + 2 - camera.position.y) * 0.02;
      camera.lookAt(0, 0, 0);
      
      // Update lighting
      light.intensity = 1.2 + Math.sin(Date.now() * 0.003) * 0.3;
      
      // Update particles
      updateParticles();
      updateStats();
      
      renderer.render(scene, camera);
    }

    // Add CSS for ripple animation
    const style = document.createElement('style');
    style.textContent = `
      @keyframes ripple {
        0% {
          transform: scale(0);
          opacity: 1;
        }
        100% {
          transform: scale(4);
          opacity: 0;
        }
      }
    `;
    document.head.appendChild(style);

    init();
  </script>
</body>
</html>
