<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P.O.P.S. Community Media Foundation - Virtual Microwave Media Player</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 5px; font-family: Arial, sans-serif; }
        #hud { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); color: white; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; display: none; }
        #fileInput { display: none; }
        #playlist { margin-top: 10px; font-size: 14px; max-height: 200px; overflow-y: auto; }
        #timer, #power { font-size: 16px; margin: 5px 0; }
        button { margin: 5px; padding: 5px 10px; cursor: pointer; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://unpkg.com/three@0.134.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat.gui/0.7.9/dat.gui.min.js"></script>
</head>
<body>
    <div id="ui">
        <button id="uploadBtn">Upload Media Files</button>
        <input type="file" id="fileInput" multiple accept="audio/*,video/*,image/*,.pdf,.txt">
        <button id="startCook">Start Cooking Playlist</button>
        <button id="stopCook">Stop</button>
        <button id="insideView">Switch to Inside View</button>
        <div id="timer">Time: 00:00</div>
        <div id="power">Power: 100%</div>
        <div id="playlist"></div>
    </div>
    <div id="hud">
        <button id="playPause">Play/Pause</button>
        <button id="skip">Skip</button>
        <button id="back">Back</button>
        <button id="menu">Menu</button>
    </div>

    <script>
        // Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffffff, 1, 10);
        pointLight.position.set(5, 5, 5);
        scene.add(pointLight);

        // Kitchen Scene
        const counterGeo = new THREE.BoxGeometry(10, 0.5, 5);
        const counterMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        const countertop = new THREE.Mesh(counterGeo, counterMat);
        countertop.position.y = -0.25;
        scene.add(countertop);

        const stoveGeo = new THREE.BoxGeometry(2, 2, 2);
        const stoveMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
        const stove = new THREE.Mesh(stoveGeo, stoveMat);
        stove.position.set(-3, 0.75, 0);
        scene.add(stove);

        const windowGeo = new THREE.PlaneGeometry(4, 3);
        const windowLoader = new THREE.TextureLoader();
        const windowMat = new THREE.MeshBasicMaterial({ 
            map: windowLoader.load('https://threejs.org/examples/textures/sky.jpg'), 
            side: THREE.DoubleSide 
        });
        const windowMesh = new THREE.Mesh(windowGeo, windowMat);
        windowMesh.position.set(0, 2, -2.5);
        windowMesh.rotation.y = Math.PI / 2;
        scene.add(windowMesh);

        // Microwave Model (Fallback if GLTF fails)
        let microwave, turntable, interiorLight, door;
        const loader = new THREE.GLTFLoader();
        loader.load(
            'https://cdn.sketchfab.com/models/d0a39d48feb448d3a215e0656e806966/optimized/microwave_oven.glb', // Sample model
            (gltf) => {
                microwave = gltf.scene;
                microwave.position.set(2, 1, 0);
                microwave.scale.set(0.5, 0.5, 0.5);
                scene.add(microwave);

                turntable = microwave.getObjectByName('Turntable') || new THREE.Mesh(
                    new THREE.CylinderGeometry(0.8, 0.8, 0.1, 32),
                    new THREE.MeshStandardMaterial({ color: 0x888888 })
                );
                if (!microwave.getObjectByName('Turntable')) {
                    turntable.position.set(2, 0.8, 0);
                    scene.add(turntable);
                }

                door = microwave.getObjectByName('Door');
                interiorLight = new THREE.PointLight(0xffff00, 0, 2);
                interiorLight.position.set(2, 1.5, 0);
                scene.add(interiorLight);
            },
            undefined,
            (error) => {
                console.error('GLTF load error:', error);
                // Fallback microwave
                const fallbackGeo = new THREE.BoxGeometry(1, 1, 1);
                const fallbackMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
                microwave = new THREE.Mesh(fallbackGeo, fallbackMat);
                microwave.position.set(2, 1, 0);
                scene.add(microwave);
                turntable = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.8, 0.8, 0.1, 32),
                    new THREE.MeshStandardMaterial({ color: 0x888888 })
                );
                turntable.position.set(2, 0.8, 0);
                scene.add(turntable);
                interiorLight = new THREE.PointLight(0xffff00, 0, 2);
                interiorLight.position.set(2, 1.5, 0);
                scene.add(interiorLight);
            }
        );

        // Media Display Surface
        const mediaGeo = new THREE.PlaneGeometry(1, 1);
        const mediaMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
        const mediaScreen = new THREE.Mesh(mediaGeo, mediaMat);
        mediaScreen.position.set(2, 1, 0);
        scene.add(mediaScreen);

        // Audio for Microwave Hum
        const listener = new THREE.AudioListener();
        camera.add(listener);
        const sound = new THREE.Audio(listener);
        const audioLoader = new THREE.AudioLoader();
        audioLoader.load(
            'https://freesound.org/data/previews/614/614418_5674468-lq.mp3', // Sample microwave hum
            (buffer) => {
                sound.setBuffer(buffer);
                sound.setLoop(true);
                sound.setVolume(0.5);
            },
            undefined,
            (error) => console.error('Audio load error:', error)
        );

        // Camera Positions
        const outsideCamPos = new THREE.Vector3(0, 2, 5);
        const insideCamPos = new THREE.Vector3(2, 1, 0.5);
        camera.position.copy(outsideCamPos);
        camera.lookAt(0, 1, 0);

        // Playlist and Media Handling
        let playlist = [];
        let currentMediaIndex = 0;
        let isCooking = false;
        let timeRemaining = 0;
        let powerLevel = 100;
        let mediaElement;
        let pdfDoc, pdfPageNum = 1;
        let txtContent = '';

        // UI Elements
        const uploadBtn = document.getElementById('uploadBtn');
        const fileInput = document.getElementById('fileInput');
        const playlistDiv = document.getElementById('playlist');
        uploadBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            playlist = Array.from(e.target.files);
            playlistDiv.innerHTML = playlist.length
                ? 'Playlist:<br>' + playlist.map((f, i) => `<div>${i + 1}. ${f.name}</div>`).join('')
                : 'No files selected';
        });

        // Power Level Control (via dat.GUI)
        const gui = new dat.GUI({ autoPlace: false });
        document.getElementById('ui').appendChild(gui.domElement);
        const settings = { powerLevel: 100 };
        gui.add(settings, 'powerLevel', 10, 100, 10).name('Power Level (%)').onChange((value) => {
            powerLevel = value;
            document.getElementById('power').textContent = `Power: ${value}%`;
        });

        // Web Worker for Timer
        const timerWorker = new Worker(URL.createObjectURL(new Blob([`
            let interval;
            self.onmessage = (e) => {
                if (e.data.action === 'start') {
                    let time = e.data.time;
                    interval = setInterval(() => {
                        time--;
                        postMessage(time);
                        if (time <= 0) clearInterval(interval);
                    }, 1000);
                } else if (e.data.action === 'stop' || e.data.action === 'pause') {
                    clearInterval(interval);
                }
            };
        `], { type: 'application/javascript' })));

        timerWorker.onmessage = (e) => {
            timeRemaining = e.data;
            document.getElementById('timer').textContent = `Time: ${Math.floor(timeRemaining / 60)}:${timeRemaining % 60 < 10 ? '0' : ''}${timeRemaining % 60}`;
            if (timeRemaining <= 0 && isCooking) playNextMedia();
        };

        // Start Cooking
        document.getElementById('startCook').addEventListener('click', () => {
            if (playlist.length > 0 && !isCooking) {
                isCooking = true;
                interiorLight.intensity = 1;
                sound.play();
                playNextMedia();
                animateTurntable(true);
                if (door) door.rotation.y = 0; // Close door
            } else if (playlist.length === 0) {
                alert('Please upload media files first!');
            }
        });

        // Stop Cooking
        document.getElementById('stopCook').addEventListener('click', stopCooking);

        function stopCooking() {
            isCooking = false;
            interiorLight.intensity = 0;
            sound.stop();
            timerWorker.postMessage({ action: 'stop' });
            if (mediaElement) {
                mediaElement.pause();
                mediaElement.remove();
                mediaElement = null;
            }
            animateTurntable(false);
            if (door) door.rotation.y = Math.PI / 2; // Open door
            mediaMat.map = null;
            mediaMat.color.set(0xffffff);
            mediaMat.needsUpdate = true;
        }

        // Play Next Media
        function playNextMedia() {
            if (currentMediaIndex >= playlist.length) {
                stopCooking();
                currentMediaIndex = 0;
                return;
            }

            const file = playlist[currentMediaIndex];
            const type = file.type.split('/')[0];
            let duration = 10;

            // Clean up previous media
            if (mediaElement) {
                mediaElement.pause();
                mediaElement.remove();
                mediaElement = null;
            }
            if (mediaMat.map) {
                mediaMat.map.dispose();
                mediaMat.map = null;
            }

            try {
                if (type === 'video' || type === 'audio') {
                    mediaElement = type === 'video' ? document.createElement('video') : document.createElement('audio');
                    mediaElement.src = URL.createObjectURL(file);
                    mediaElement.autoplay = true;
                    mediaElement.loop = false;
                    mediaElement.addEventListener('loadedmetadata', () => {
                        duration = mediaElement.duration;
                        startTimer(duration);
                    });
                    mediaElement.addEventListener('ended', playNextMedia);
                    mediaElement.addEventListener('error', () => {
                        console.error('Media load error:', file.name);
                        playNextMedia();
                    });
                    if (type === 'video') {
                        const videoTexture = new THREE.VideoTexture(mediaElement);
                        mediaMat.map = videoTexture;
                        mediaMat.needsUpdate = true;
                    }
                } else if (type === 'image') {
                    const imgTexture = new THREE.TextureLoader().load(
                        URL.createObjectURL(file),
                        () => {
                            mediaMat.map = imgTexture;
                            mediaMat.needsUpdate = true;
                            startTimer(duration);
                            setTimeout(playNextMedia, duration * 1000);
                        },
                        undefined,
                        (error) => {
                            console.error('Image load error:', error);
                            playNextMedia();
                        }
                    );
                } else if (file.type === 'application/pdf') {
                    pdfjsLib.getDocument(URL.createObjectURL(file)).promise.then((doc) => {
                        pdfDoc = doc;
                        pdfPageNum = 1;
                        renderPdfPage();
                    }).catch((error) => {
                        console.error('PDF load error:', error);
                        playNextMedia();
                    });
                } else if (file.type === 'text/plain') {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        txtContent = e.target.result;
                        renderTextToCanvas(txtContent);
                        startTimer(duration);
                        setTimeout(playNextMedia, duration * 1000);
                    };
                    reader.onerror = () => {
                        console.error('Text load error:', file.name);
                        playNextMedia();
                    };
                    reader.readAsText(file);
                } else {
                    console.error('Unsupported file type:', file.type);
                    playNextMedia();
                }
            } catch (error) {
                console.error('Error processing media:', error);
                playNextMedia();
            }

            currentMediaIndex++;
        }

        // Render PDF to Canvas
        const pdfCanvas = document.createElement('canvas');
        const pdfCtx = pdfCanvas.getContext('2d');
        function renderPdfPage() {
            if (!pdfDoc) return;
            pdfDoc.getPage(pdfPageNum).then((page) => {
                const viewport = page.getViewport({ scale: 1 });
                pdfCanvas.width = viewport.width;
                pdfCanvas.height = viewport.height;
                page.render({ canvasContext: pdfCtx, viewport }).promise.then(() => {
                    const pdfTexture = new THREE.CanvasTexture(pdfCanvas);
                    mediaMat.map = pdfTexture;
                    mediaMat.needsUpdate = true;
                    startTimer(10);
                    setTimeout(() => {
                        pdfPageNum++;
                        if (pdfPageNum <= pdfDoc.numPages) renderPdfPage();
                        else playNextMedia();
                    }, 10000);
                });
            }).catch((error) => {
                console.error('PDF page render error:', error);
                playNextMedia();
            });
        }

        // Render Text to Canvas
        function renderTextToCanvas(text) {
            pdfCanvas.width = 800;
            pdfCanvas.height = 600;
            pdfCtx.fillStyle = 'white';
            pdfCtx.fillRect(0, 0, 800, 600);
            pdfCtx.fillStyle = 'black';
            pdfCtx.font = '20px Arial';
            const lines = text.split('\n').slice(0, 20); // Limit lines for performance
            lines.forEach((line, i) => pdfCtx.fillText(line, 10, 30 + i * 25));
            const txtTexture = new THREE.CanvasTexture(pdfCanvas);
            mediaMat.map = txtTexture;
            mediaMat.needsUpdate = true;
        }

        // Animate Turntable
        let turntableAnimating = false;
        function animateTurntable(animate) {
            turntableAnimating = animate;
        }

        // Inside View Switch
        let insideView = false;
        const insideViewBtn = document.getElementById('insideView');
        insideViewBtn.addEventListener('click', () => {
            insideView = !insideView;
            insideViewBtn.textContent = insideView ? 'Switch to Outside View' : 'Switch to Inside View';
            camera.position.copy(insideView ? insideCamPos : outsideCamPos);
            camera.lookAt(2, 1, 0);
            document.getElementById('hud').style.display = insideView ? 'block' : 'none';
        });

        // HUD Controls
        document.getElementById('playPause').addEventListener('click', () => {
            if (mediaElement) {
                if (mediaElement.paused) {
                    mediaElement.play();
                    timerWorker.postMessage({ action: 'start', time: timeRemaining });
                } else {
                    mediaElement.pause();
                    timerWorker.postMessage({ action: 'pause' });
                }
            }
        });
        document.getElementById('skip').addEventListener('click', playNextMedia);
        document.getElementById('back').addEventListener('click', () => {
            currentMediaIndex = Math.max(0, currentMediaIndex - 2);
            playNextMedia();
        });
        document.getElementById('menu').addEventListener('click', () => alert('Menu: Settings, Power Level, etc.'));

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);
            if (turntableAnimating && turntable) {
                turntable.rotation.y += 0.01 * (powerLevel / 100); // Scale rotation with power
            }
            renderer.render(scene, camera);
        }
        animate();

        // Resize Handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // AI Integration Placeholder
        /*
        async function aiProcess(prompt) {
            // Requires xAI API setup: https://x.ai/api
            console.log('AI processing not implemented. Visit https://x.ai/api for API details.');
        }
        */
    </script>
</body>
</html>
